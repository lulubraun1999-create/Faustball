/**
 * @fileoverview Firestore Security Rules for FaustApp.
 *
 * Core Philosophy:
 * This ruleset enforces a combination of user-ownership and role-based access control.
 * User documents are secured using an ownership model, while appointments and groups are publicly readable but admin-writable.
 *
 * Data Structure:
 * - /users/{userId}: Stores core user data. Access is restricted to the user and admins.
 * - /members/{memberId}: Stores detailed user profile data. Access is restricted to the user and admins.
 * - /appointments/{appointmentId}: Stores appointment data. Publicly readable, only admins can write.
 * - /groups/{groupId}: Stores group data. Publicly readable, only admins can write.
 *
 * Key Security Decisions:
 * - User listing is implicitly denied (no `list` rule on `/users`).
 * - Read-only collections like `/appointments` and `/groups` are made public to all users by using `allow get, list: if true;`.
 * - Admin role is not explicitly enforced in this prototype but should be implemented in the future.
 *
 * Denormalization for Authorization:
 *  - The `Member` document has a `userId` field to link it to the corresponding `User` document. This avoids the need for complex queries to check ownership.
 *
 * Structural Segregation:
 *  - No public/private segregation is implemented, as all top-level collections are either user-owned or publicly readable.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures core user data, allowing only the user or an admin to read and write.
     * @path /users/{userId}
     * @allow (get, create, update, delete) User with matching {userId} in request.auth
     * @deny (get, create, update, delete) User with non-matching {userId} in request.auth
     * @principle Enforces user ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures editable user profile data, allowing only the user or an admin to read and write.
     * @path /members/{memberId}
     * @allow (get, create, update, delete) User with matching userId in request.auth
     * @deny (get, create, update, delete) User with non-matching userId in request.auth
     * @principle Enforces document ownership for writes and restricts access to a user's own profile data.
     */
    match /members/{memberId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwnerByUserId(userId) {
        return get(/databases/$(database)/documents/users/$(userId)).data.id == request.auth.uid;
      }

      function isExistingOwnerByUserId(userId) {
        return isOwnerByUserId(get(/databases/$(database)/documents/members/$(memberId)).data.userId) && resource.data != null;
      }

      allow get: if isSignedIn() && get(/databases/$(database)/documents/members/$(memberId)).data.userId == request.auth.uid;
      allow list: if false;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/members/$(memberId)).data.userId == request.auth.uid;
    }

    /**
     * @description Stores all appointments. Writable only by admins, readable by all users.
     * @path /appointments/{appointmentId}
     * @allow (get, list) Any signed-in user
     * @deny (create, update, delete) Any non-admin user
     * @principle Public read, admin-only write.
     */
    match /appointments/{appointmentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Stores all groups (classes and teams). Writable only by admins, readable by all users.
     * @path /groups/{groupId}
     * @allow (get, list) Any signed-in user
     * @deny (create, update, delete) Any non-admin user
     * @principle Public read, admin-only write.
     */
    match /groups/{groupId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }
  }
}