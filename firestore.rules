/**
 * @fileoverview Firestore Security Rules for FaustApp.
 *
 * Core Philosophy:
 * This ruleset enforces a combination of user-ownership and role-based access control.
 * User documents are secured using an ownership model, while appointments and groups are readable by all but writable only by admins.
 *
 * Data Structure:
 * - /users/{userId}: User authentication data (read-only after creation).
 * - /members/{memberId}: Editable user profile data.
 * - /appointments/{appointmentId}: Calendar events (readable by all, writable by admins).
 * - /groups/{groupId}: Classes and teams (readable by all, writable by admins).
 *
 * Key Security Decisions:
 * - User listing is explicitly denied to prevent information harvesting.
 * - The `id` field in `/users/{userId}` must match the `userId` in the path on creation and be immutable on updates.
 * - Appointments and groups are readable by all users.
 *
 * Denormalization for Authorization:
 *  - For simplicity, there is an assumption that the memberId matches the userId in the /members collection. This avoids extra reads to link user and member documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile data, ensuring only the user or an admin can access it.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their own document.
     * @allow (get) User with matching UID can read their own document.
     * @allow (update) User with matching UID can update their own document.
     * @allow (delete) User with matching UID can delete their own document.
     * @deny (list) Prevents listing all users.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures member profile data, ensuring only the user or an admin can access it.
     * @path /members/{memberId}
     * @allow (create) User with matching UID can create their own member document.
     * @allow (get) User with matching UID can read their own member document.
     * @allow (update) User with matching UID can update their own member document.
     * @allow (delete) User with matching UID can delete their own member document.
     * @deny (list) Prevents listing all members,
     * @principle Enforces document ownership for writes.
     */
    match /members/{memberId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(memberId) {
        return request.auth.uid == memberId;
      }

      function isExistingOwner(memberId) {
        return isOwner(memberId) && resource != null;
      }

      allow get: if isOwner(memberId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(memberId);
      allow update: if isExistingOwner(memberId);
      allow delete: if isExistingOwner(memberId);
    }

    /**
     * @description Secures appointment data, allowing public read access and admin-only write access.
     * @path /appointments/{appointmentId}
     * @allow (get) Any user can read appointment data.
     * @allow (list) Any user can list appointment data.
     * @deny (create) Only admins can create appointments.
     * @deny (update) Only admins can update appointments.
     * @deny (delete) Only admins can delete appointments.
     */
    match /appointments/{appointmentId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation once role management is implemented
    }

    /**
     * @description Secures group data, allowing public read access and admin-only write access.
     * @path /groups/{groupId}
     * @allow (get) Any user can read group data.
     * @allow (list) Any user can list group data.
     * @deny (create) Only admins can create groups.
     * @deny (update) Only admins can update groups.
     * @deny (delete) Only admins can delete groups.
     */
    match /groups/{groupId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation once role management is implemented
    }
  }
}