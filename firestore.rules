rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }
    function isAdmin() {
      return request.auth.token.admin == true;
    }
    // Holt die Team-IDs des anfragenden Benutzers aus seinem Member-Dokument
    function getUserTeams() {
      return get(/databases/$(database)/documents/members/$(request.auth.uid)).data.teams;
    }
    // Prüft, ob der Benutzer Mitglied eines bestimmten Teams ist
    function isMemberOfTeam(teamId) {
      return isSignedIn() && teamId in getUserTeams();
    }
     // Prüft, ob der Benutzer Mitglied des Teams ist, zu dem das Dokument gehört (für get)
    function isMemberOfDocTeam() {
      return isSignedIn() && resource.data.teamId in getUserTeams();
    }


    /**
     * @description Controls access to user accounts.
     * Only the user or an admin can read/write.
     * @path /users/{userId}
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isCreatingOwnDocument(userId) {
        return request.auth.uid == userId &&
               request.resource.data.id == userId &&
               (request.resource.data.role == 'user' || !('role' in request.resource.data));
      }
       function isUpdatingOwnDocument(userId) {
         return isOwner(userId) && !('role' in request.resource.data);
       }
       function isAdminUpdatingDocument(userId) {
         return isAdmin();
       }
       function isOwnerDeleting(userId) {
          return isOwner(userId);
       }

      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if false;
      allow create: if isSignedIn() && isCreatingOwnDocument(userId);
      allow update: if isSignedIn() && (isUpdatingOwnDocument(userId) || isAdminUpdatingDocument(userId));
      allow delete: if isSignedIn() && (isOwnerDeleting(userId) || isAdmin());
    }

    /**
     * @description Controls access to member profiles.
     * Only the user or an admin can read/write/list.
     * @path /members/{memberId}
     */
    match /members/{memberId} {
        function isOwner(memberId) {
            return request.auth.uid == memberId;
        }
         function isExistingOwner(memberId) {
           return isSignedIn() && exists(/databases/$(database)/documents/members/$(memberId)) && resource.data.userId == request.auth.uid;
         }
        function isCreatingOwnProfile(memberId) {
            return request.auth.uid == memberId && request.resource.data.userId == request.auth.uid;
        }

        allow get: if isSignedIn() && (isOwner(memberId) || isAdmin());
        allow list: if isSignedIn() && isAdmin();
        allow create: if isSignedIn() && isCreatingOwnProfile(memberId);
        allow update, delete: if isSignedIn() && (isExistingOwner(memberId) || isAdmin());
    }

    /**
     * @description Controls access to the list of group members.
     * Publicly readable, admin-writeable.
     * @path /groups/{groupId}/members/{memberId}
     */
    match /groups/{groupId}/members/{memberId} {
        allow get, list: if true;
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to appointments. Publicly readable, admin-writeable.
     * @path /appointments/{appointmentId}
     */
    match /appointments/{appointmentId} {
        allow get, list: if true;
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to groups (classes and teams).
     * Publicly readable, admin-writeable.
     * @path /groups/{groupId}
     */
    match /groups/{groupId} {
        allow get, list: if true;
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to polls.
     * Read access depends on poll visibility. Admin-writeable.
     * Users can update votes.
     * @path /polls/{pollId}
     */
    match /polls/{pollId} {
        function isMemberOfVisibleTeam() {
          // Prüft, ob das Member-Dokument existiert, bevor auf 'teams' zugegriffen wird
          let memberDoc = get(/databases/$(database)/documents/members/$(request.auth.uid));
          return memberDoc.data != null && resource.data.visibility.teamIds.hasAny(memberDoc.data.teams);
        }

        allow get, list: if isSignedIn() && (resource.data.visibility.type == 'all' || isMemberOfVisibleTeam());
        allow create, delete: if isSignedIn() && isAdmin();
        allow update: if isSignedIn() && (
                      isAdmin() ||
                      (isMemberOfVisibleTeam() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['votes']))
                    );
    }

    /**
     * @description Controls access to news articles. Publicly readable, admin-writeable.
     * @path /news/{newsId}
     */
    match /news/{newsId} {
        allow get, list: if true;
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to treasury transactions.
     * Admins can read/write all. Members can read transactions for their teams.
     * @path /treasury/{transactionId}
     */
    match /treasury/{transactionId} {
        // Lesen: Erlaubt für Admins ODER Mitglieder des entsprechenden Teams
        allow get, list: if isSignedIn() && (isAdmin() || isMemberOfDocTeam());
        // Schreiben: Nur für Admins
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to penalty rules.
     * Admins can read/write all. Members can read penalties for their teams.
     * @path /penalties/{penaltyId}
     */
    match /penalties/{penaltyId} {
       // Lesen: Erlaubt für Admins ODER Mitglieder des entsprechenden Teams
       allow get, list: if isSignedIn() && (isAdmin() || isMemberOfDocTeam());
       // Schreiben: Nur für Admins
       allow write: if isSignedIn() && isAdmin();
    }
  }
}