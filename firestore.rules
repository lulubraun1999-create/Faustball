rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }
    function isAdmin() {
      // Prüft, ob der Benutzer den Admin-Claim im Token hat
      return request.auth.token.admin == true;
    }
    // Holt die Team-IDs des anfragenden Benutzers aus seinem Member-Dokument
    function getUserTeams() {
      // Stelle sicher, dass das Dokument existiert, bevor auf 'teams' zugegriffen wird
      let memberDoc = get(/databases/$(database)/documents/members/$(request.auth.uid));
      return memberDoc.data != null ? memberDoc.data.teams : []; // Leere Liste zurückgeben, wenn kein Profil
    }
    // Prüft, ob der Benutzer Mitglied eines bestimmten Teams ist
    function isMemberOfTeam(teamId) {
      return isSignedIn() && teamId in getUserTeams();
    }
     // Prüft, ob der Benutzer Mitglied des Teams ist, zu dem das Dokument gehört (für get)
    function isMemberOfDocTeam() {
      // Stelle sicher, dass das Dokument 'teamId' hat und getUserTeams() nicht null ist
      return isSignedIn() && resource.data.keys().hasAny(['teamId']) && resource.data.teamId in getUserTeams();
    }


    /**
     * @description Controls access to user accounts.
     * Only the user or an admin can read/write.
     * @path /users/{userId}
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isCreatingOwnDocument(userId) {
        return request.auth.uid == userId &&
               request.resource.data.id == userId &&
               (request.resource.data.role == 'user' || !('role' in request.resource.data));
      }
       function isUpdatingOwnDocument(userId) {
         // Erlaubt dem Besitzer, sein eigenes Dokument zu aktualisieren,
         // aber NICHT die Rolle zu ändern (außer Admins).
         return isOwner(userId) && !('role' in request.resource.data);
       }
       function isAdminUpdatingDocument(userId) {
         // Erlaubt Admins, jedes Benutzerdokument zu aktualisieren (einschließlich der Rolle).
         return isAdmin();
       }
       function isOwnerDeleting(userId) {
          // Stellt sicher, dass der Benutzer nur sein eigenes Dokument löschen kann
          return isOwner(userId);
       }

      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if isSignedIn() && isAdmin(); // Admins dürfen auflisten
      allow create: if isSignedIn() && isCreatingOwnDocument(userId);
      allow update: if isSignedIn() && (isUpdatingOwnDocument(userId) || isAdminUpdatingDocument(userId));
      allow delete: if isSignedIn() && (isOwnerDeleting(userId) || isAdmin()); // Admins dürfen auch löschen
    }

    /**
     * @description Controls access to member profiles.
     * Only the user or an admin can read/write/list.
     * @path /members/{memberId}
     */
    match /members/{memberId} {
        // isOwner prüft, ob die Auth-UID mit der ID des Dokuments übereinstimmt (für get)
        // oder mit der userId im bestehenden Dokument (für update/delete)
        function isOwner(memberId) {
            return request.auth.uid == memberId;
        }
         function isExistingOwner(memberId) {
           // Überprüft, ob der Benutzer der Eigentümer des vorhandenen Dokuments ist
           return isSignedIn() && exists(/databases/$(database)/documents/members/$(memberId)) && resource.data.userId == request.auth.uid;
         }
        function isCreatingOwnProfile(memberId) {
            // Stellt sicher, dass die Dokument-ID mit der userId im Request übereinstimmt
            // und dass diese userId die des angemeldeten Benutzers ist.
            return request.auth.uid == memberId && request.resource.data.userId == request.auth.uid;
        }

        // Lesen: Erlaubt für den Besitzer ODER einen Admin
        allow get: if isSignedIn() && (isOwner(memberId) || isAdmin());
        // Auflisten: Erlaubt NUR für Admins
        allow list: if isSignedIn() && isAdmin();
        // Erstellen: Erlaubt für den Benutzer, der sein eigenes Profil erstellt
        allow create: if isSignedIn() && isCreatingOwnProfile(memberId);
        // Aktualisieren/Löschen: Erlaubt NUR für den Besitzer ODER einen Admin
        allow update, delete: if isSignedIn() && (isExistingOwner(memberId) || isAdmin());
    }

       /**
        * @description Controls access to the list of group members.
        * Publicly readable, admin-writeable.
        * @path /groups/{groupId}/members/{memberId}
        */
      match /groups/{groupId}/members/{memberId} {
        // Lesen ist öffentlich erlaubt
        allow get, list: if true;
        // Schreiben (Erstellen, Ändern, Löschen) nur für Admins
        allow write: if isSignedIn() && isAdmin();
      }

    /**
     * @description Controls access to groups (classes and teams).
     * Publicly readable, admin-writeable.
     * @path /groups/{groupId}
     */
    match /groups/{groupId} {
        allow get, list: if true; // Jeder kann lesen
        allow write: if isSignedIn() && isAdmin(); // Nur Admins können schreiben
    }

    // --- NEUE REGELN ---
    /**
     * @description Controls access to Appointment Types. Readable by all, writable by admin.
     * @path /appointmentTypes/{typeId}
     */
    match /appointmentTypes/{typeId} {
        allow read: if true; // Jeder darf Typen lesen
        allow write: if isSignedIn() && isAdmin(); // Nur Admins dürfen Typen ändern/erstellen
    }

    /**
     * @description Controls access to Locations. Readable by all, writable by admin.
     * @path /locations/{locationId}
     */
    match /locations/{locationId} {
        allow read: if true; // Jeder darf Orte lesen
        allow write: if isSignedIn() && isAdmin(); // Nur Admins dürfen Orte ändern/erstellen
    }
    // --- ENDE NEUE REGELN ---


    /**
     * @description Controls access to appointments.
     * Admins can read/write all. Members can read appointments visible to them.
     * @path /appointments/{appointmentId}
     */
    match /appointments/{appointmentId} {
        // Hilfsfunktion: Prüft, ob der Benutzer Mitglied mindestens eines Teams ist, für das der Termin sichtbar ist
        function isMemberOfVisibleTeamForAppointment() {
          let memberDoc = get(/databases/$(database)/documents/members/$(request.auth.uid));
          // Prüft auf Überschneidung zwischen den Teams des Mitglieds und den sichtbaren Teams des Termins
          // Stellt sicher, dass visibility.teamIds existiert, bevor hasAny aufgerufen wird
          return memberDoc.data != null &&
                 resource.data.visibility.keys().hasAny(['teamIds']) &&
                 resource.data.visibility.teamIds.hasAny(memberDoc.data.teams);
        }

        // Lesen (get, list): Erlaubt für Admins ODER wenn der Termin für alle sichtbar ist ODER der Benutzer Mitglied eines sichtbaren Teams ist
        allow read: if isSignedIn() && (isAdmin() || resource.data.visibility.type == 'all' || isMemberOfVisibleTeamForAppointment());

        // Schreiben (create, update, delete): Nur für Admins
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to polls.
     * Read access depends on poll visibility. Admin-writeable.
     * Users can update votes.
     * @path /polls/{pollId}
     */
    match /polls/{pollId} {
        function isMemberOfVisibleTeamForPoll() {
          let memberDoc = get(/databases/$(database)/documents/members/$(request.auth.uid));
          return memberDoc.data != null &&
                 resource.data.visibility.keys().hasAny(['teamIds']) &&
                 resource.data.visibility.teamIds.hasAny(memberDoc.data.teams);
        }

        allow get, list: if isSignedIn() && (resource.data.visibility.type == 'all' || isMemberOfVisibleTeamForPoll());
        allow create, delete: if isSignedIn() && isAdmin();
        allow update: if isSignedIn() && (
                      isAdmin() ||
                      (isMemberOfVisibleTeamForPoll() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['votes']))
                    );
    }

    /**
     * @description Controls access to news articles. Publicly readable, admin-writeable.
     * @path /news/{newsId}
     */
    match /news/{newsId} {
        allow get, list: if true; // Jeder kann lesen
        allow write: if isSignedIn() && isAdmin(); // Nur Admins können schreiben
    }

    /**
     * @description Controls access to treasury transactions.
     * Admins can read/write all. Members can read transactions for their teams.
     * @path /treasury/{transactionId}
     */
    match /treasury/{transactionId} {
        allow get, list: if isSignedIn() && (isAdmin() || isMemberOfDocTeam());
        allow write: if isSignedIn() && isAdmin();
    }

    /**
     * @description Controls access to penalty rules.
     * Admins can read/write all. Members can read penalties for their teams.
     * @path /penalties/{penaltyId}
     */
    match /penalties/{penaltyId} {
       allow get, list: if isSignedIn() && (isAdmin() || isMemberOfDocTeam());
       allow write: if isSignedIn() && isAdmin();
    }
  }
}